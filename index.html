<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="John Doe"><meta name="copyright" content="John Doe"><title>Schneey's notebook</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '5.3.0'
} </script><meta name="generator" content="Hexo 5.3.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">John Doe</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">4</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Schneey's notebook</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right"></span></div><div id="site-info"><div id="site-title">Schneey's notebook</div><div id="site-sub-title"></div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2021/01/18/firstPage-md/">firstPage.md</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-01-18</time><div class="content"><h2 id="hello"><a href="#hello" class="headerlink" title="hello"></a>hello</h2></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/01/18/hello-world/">Hello World</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-01-18</time><div class="content"><p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/08/25/21%E5%A4%A9%E7%BB%8F%E6%B5%8E%E5%AD%A6/">No title</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-08-25</time><div class="content"><p>#简单经济金融笔记</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>现代社会是一个激动人心的社会。</p>
<p>经济是研究资源如何配置。金融是研究人如果跨越时空的去调配这些资源。</p>
<p>###大数定理</p>
<p>大数定理，目前创投圈逻辑成立的基础保障。投足够看好的多的企业，最终收益收敛到企业的期望。幂律分布，小成功概率，但是带来的收益是巨大的。在自然界或者在经济上大部分是符合幂律的。</p>
<p>如何判断一个事情是合理的呢？</p>
<ul>
<li><p>历史判断</p>
</li>
<li><p>逻辑判断</p>
</li>
</ul>
<p>历史判断不可信，如旁氏骗局（e租宝、麦道夫、p2p等）。</p>
<p>投资背后的机理是否符合逻辑，数学可信。</p>
<p>近乎免费的互联网：</p>
<p>后期回报大，用户基数大，成本平均摊薄，通过广告收回成本，这样服务就接近免费。互联网涉及用户多，边际成本可以将到很低。互联网中，企业、投资者、用户都在受益，共同受益，称为非零和情况。像土地资源是零和资源。</p>
<p>###法律是基础</p>
<p>英国大宪章-&gt;人治变法治-&gt;财产权、股权、股票及其衍生品期权期货。</p>
<pre><code class="mermaid">graph TD
A[法治:英国大宪章]
B[产权:亚当斯密]
C[新社会:契约]
D[资本:风投]
A--&gt;B
B--&gt;C
C--&gt;D

</code></pre>
<h2 id="科技与文明"><a href="#科技与文明" class="headerlink" title="科技与文明"></a>科技与文明</h2><h3 id="人作为社会的基础单元"><a href="#人作为社会的基础单元" class="headerlink" title="人作为社会的基础单元"></a>人作为社会的基础单元</h3><p>人与人之前的互动和企业之间的互动分为三类：</p>
<ul>
<li><p>零和。升学名额（效益不是零和）</p>
</li>
<li><p>负和。战争</p>
</li>
<li><p>正和。分为两种，一方受损和帕累托改进。</p>
</li>
</ul>
<p>​     帕累托改进：每一方都要大于等于原来的状态。亚当斯密在国富论中这样描述帕累托改进：在资本主义的一种运作方式里面，所有人都是基于自利在进行决策。他认为所有人都是自私的，即使所有人都是自私的，每个人做出仅对自己好的决定，社会也能很好的运作下去。“我们所需的食物不是出自屠夫、酿酒师、面包师的恩惠，而仅仅是出于他们对自身利益的顾虑。我们不要求他们的爱心，只要说对他们有利，这个社会就能运作下去。” 有别于这种社会运作的方式是会考虑到别人的利益，但是很多事情可能是基于善意，却可能会伤害到个体的决定，因为这个运作模式不是帕累托改进。例如乌克兰大饥荒，三年自然灾害。</p>
<p>自利–&gt;帕累托改进–&gt;社会越来越好</p>
<p><strong>在正常的自由市场下，所有的东西都是帕累托改进</strong>。</p>
<p>最底层的逻辑：</p>
<p>亚当斯密认为： 人与人通过自利的公平的自由交换，双方都受益，而这受益不断的延续往复，社会财富就增加了。</p>
<p>注意帕累托改进是有前提的，两个基石：</p>
<ul>
<li>透明。信息完全，非骗局。旁氏骗局隐藏了信息。</li>
<li>法制。</li>
</ul>
<h3 id="文明的构建"><a href="#文明的构建" class="headerlink" title="文明的构建"></a>文明的构建</h3><pre><code class="mermaid">graph TD
A[人:法人]
B[社群]
C[分工-&gt;效率提升]
D[公共服务-&gt;政府:税收]
E[自由交换-&gt;帕累托改进]

A--&gt;B
B--&gt;C
C--&gt;D
D--&gt;E</code></pre>
<h3 id="科技和金融谁先行"><a href="#科技和金融谁先行" class="headerlink" title="科技和金融谁先行"></a>科技和金融谁先行</h3><p>陈志武教授在《金融的逻辑》中提了一个观点：因为金融工具的先进化，因为金融产品的诞生，因为金融交易平台的出现，导致了社会资源能够很好的去配置，因为很好的配置，财富得到了创造，顺便养活了更多的科研人员。 他认为是金融工具的产生使科技得到了一个突飞猛进的发展。</p>
<h2 id="金融市场"><a href="#金融市场" class="headerlink" title="金融市场"></a>金融市场</h2><h3 id="抽象改变世界"><a href="#抽象改变世界" class="headerlink" title="抽象改变世界"></a>抽象改变世界</h3><p>人类世界正数转移</p>
<p>钱不过是银行的数字而已？ 错误的还原论</p>
<p>买卖股票就赚钱的人对社会没有贡献？</p>
<p>认为发动机的制造这种进步，才是社会的进步。而金融工具的进步只不过是一种高级的骗术？</p>
<p>金融工具是基于一种抽象的东西，可以更好的去调配仅仅大于等于0的正数资源。</p>
<p>time value 时间价值，一种时间价值的思考方式来帮助我们衡量一个投资、一个金融产品它的价值</p>
<p>不同的抽象导致金融上不同的创新</p>
<p>机会的价值，未来的价值</p>
<p>直接社会的实体由不同的人组成，自然人和法人。法人可以发行股份，股份是可以买卖的，所有股份的买卖都叫做一级市场（PE市场）</p>
<p>VC（venture capital）风险资本</p>
<p> PE （private equity）</p>
<p>一个公司从一级市场成熟以后，上市，变成了二级市场</p>
<p>二级市场最大的特点是面向公众的。</p>
<p>二级市场可以股票买卖，这是一种抽象。股票买卖可以衍生出更多的抽象，预测之后是会涨会跌这个事情也衍生出一个金融工具–期权。有看涨期权 和 看跌期权</p>
<p>买看涨期权，认为它会涨，判断对会有相应的回报。</p>
<img src="/Users/shein/Library/Application Support/typora-user-images/image-20200829142958218.png" alt="image-20200829142958218" style="zoom:50%;" />



<p>期权不需要占有实体， 而只是购买了涨跌的可能性。</p>
<p>期权就是在未来有买入卖出的权利</p>
<p>杠杆，双刃剑。</p>
<p>基于二级市场产生的抽象金融产品也是 有价值。</p>
<p>综上，机会的价值也可以被衡量</p>
<p>信用违约互换 CDS credit default swap</p>
<p>不违约安好，违约替你承担风险，要是违约的风险被错误的估算就会出现很大的问题。</p>
<p>中国的房贷市场，是个人向银行贷款，个人给银行多次分期付款，银行一次性给房企，房企和银行很早交换，房契在银行，如果中间分期付款中断，房子归银行所有。</p>
<p>个人违约有两种情况，一是个人原因，二是经济危机大数人经济出现问题。</p>
<p>如果是后者的情况，银行会承担很大的风险，为了考虑这个问题，银行总的放贷量会控制，导致想转移风险。</p>
<p>次贷危机与金融市场</p>
<p>美国上一轮金融危机最邪恶的根源 CDS，美国房价压力，政府办理两房 。</p>
<p>美国出现了正常市场下的自由机构</p>
<p>fannie mae</p>
<p>freddie mac</p>
<p>给银行很大的保障资金，让银行完成放贷。</p>
<p>如果中间出现大量的违约，受损</p>
<p>房地美把房子的一组契约 ，打包丢到华尔街去买，分割为不同的金融产品，不同的产品，不同的风险， 不同的定价。错误的评估了风险，连锁型问题。</p>
<p>这样的金融产品是很有用的，可以帮助一些投资方进行对冲，但是如果产品的评估是错误的，不透明的，就会使对冲的人承担了额外不自知的风险。</p>
<p>用帕累托改进来解释的话，新的金融抽象可以产生新的买卖，新的买卖如果是透明的，那对双方都好。而抽象出更多的东西就能产生很多的买卖。</p>
<h3 id="不断创新的金融产品"><a href="#不断创新的金融产品" class="headerlink" title="不断创新的金融产品"></a>不断创新的金融产品</h3><img src="/Users/shein/Library/Application Support/typora-user-images/image-20200829145149119.png" alt="image-20200829145149119" style="zoom:50%;" />





<p>例如</p>
<p>一个航空企业的年利润5%，大量的资金消耗是航空用油的购买，航空用油的价格子啊一年之内涨了20%，这样就会让企业破产。这个时候如果有期货买卖可以进行对冲，企业买一些期货，未来原油价格如果涨的话，现在低买，之后可以卖掉 对冲风险。</p>
<p>航空用油可能没有 期货，但是原油有期货</p>
<p>和保险差不多，风险对冲，摊平</p>
<p>石油生产商为了对冲风险（万一石油降价）成为自然的卖方，航空公司成为买房，投机者为其提供流动性。</p>
<p>市场是发现价格的一个工具</p>
<p>有没有市场都会有价格，但是这个价格并不能反映供求关系，而反映供求关系的价格，是由市场来发现的。市场发现价格才是真正的均衡价格，而偏离市场均衡价格的所有买卖都会导致损失。</p>
<p>一级市场的流动性远远小于二级市场。</p>
<p>toy model</p>
<h2 id="供求关系"><a href="#供求关系" class="headerlink" title="供求关系"></a>供求关系</h2><p>假设只有一种货物</p>
<p>1）消费者群体，自利</p>
<p>两个 tony model</p>
<p>P价格 Q销量</p>
<p>假设物品无限可分</p>
<p>需求曲线，供给曲线</p>
<p>![image-20200829152051388](/Users/shein/Library/Application Support/typora-user-images/image-20200829152051388.png)</p>
<p>均衡价格的发现，需要时间。动态变化</p>
<p>平衡态的一个统计物理</p>
<p>上面是群体行为</p>
<p>个人行为：</p>
<p>更加具体，并没有均衡价格</p>
<p>怎么理解个人的买卖，</p>
<p>买家的受益</p>
<p>卖家的成本</p>
<p>因为这次买卖，对卖家和买家都是帕累托改进。</p>
<p>![image-20200829152832612](/Users/shein/Library/Application Support/typora-user-images/image-20200829152832612.png)</p>
<p>社会总收益</p>
<p>差价就是为社会创造的财富</p>
<p>三角形的面积</p>
<p>![image-20200829165056093](/Users/shein/Library/Application Support/typora-user-images/image-20200829165056093.png)</p>
<p>![image-20200829165237589](/Users/shein/Library/Application Support/typora-user-images/image-20200829165237589.png)</p>
<p>基于tony model 分析</p>
<p>火车票如果在春运期间不涨价会？？</p>
<p>技术生产力，导致被动降低供应曲线</p>
<p>![image-20200829165719827](/Users/shein/Library/Application Support/typora-user-images/image-20200829165719827.png)</p>
<p>如果供应曲线下降，会导致社会福祉上升，总的销量会增加</p>
<p>加入新的供应曲线，创造新的技术。</p>
<p>曲面三角形</p>
<p>社会财富的提升 有两条路径，一是在原有基础上改进（降低供应曲线），二是颠覆性的创新</p>
<p>一个货物诞生在这个世界上对双方需要以及制作的话 就能给社会带来财富</p>
<h2 id="经济与社会"><a href="#经济与社会" class="headerlink" title="经济与社会"></a>经济与社会</h2><p>如果人不自利 可能会给社会带来好的结果，但是这种结果是不稳定的</p>
<p>A社会：复杂的均衡决策，自利群体</p>
<p>A-社会：利他社会</p>
<p>假设两个社会 做的事情完全一样，他们的社会效率，发明的创造力可能是一样的。社会仍然能运作。</p>
<p>因为锁（密码）的存在，需要锁和解开锁的需求，A对抗机制出现，如果A-社会不需要锁的资源能够节约出来，做一些创造性的东西，那么A-社会就优于A社会了。综上，发现完全利他的社会我们可以模拟出一种情况要比自利的社会要好。可能亚当斯密给的一个社会可能不是人类社会的最优解</p>
<p>然而这样的利他社会是不稳定的，如果有人利己的话，可能会利用别人的利他性而去获取额外的财富，最终导致整体社会的稳定的破坏。</p>
<p>整体利己，局部利他</p>
<p>劳动力市场</p>
<p>政府出台 最低工资标准（蓝色），低于基本价格 没有影响</p>
<p>可替代性很强 的市场</p>
<p>政府出台 最低工资标准高于 基本价格 ，导致部分人员失业  无谓损失QWL</p>
<p>保护了社会工作能力强的人</p>
<p>社会福利：曲线三角形</p>
<p>![image-20200829191623301](/Users/shein/Library/Application Support/typora-user-images/image-20200829191623301.png)</p>
<p>权力寻租</p>
<p>10万人中选择7万人进行聘职</p>
<p>租：租值</p>
<p>SMIC</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/08/17/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%AC%94%E8%AE%B0/">No title</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-08-17</time><div class="content"><h2 id="第八章多态"><a href="#第八章多态" class="headerlink" title="第八章多态"></a>第八章多态</h2><hr>
<h2 id="第九章多态"><a href="#第九章多态" class="headerlink" title="第九章多态"></a>第九章多态</h2><p>多态是面向对象编程语言中，继数据抽象和继承之外的第三个重要特性</p>
<p><strong>封装通过合并特征和行为来创建新的数据类型，隐藏实现通过将细节私有化把接口与实现分离。而多态是消除类型之间的耦合。</strong></p>
<p><strong>多态方法调用允许一种类型表现出与相似类型的区别，只要这些类型派生自一个基类。这种区别是当你通过基类调用时，由方法的不同行为表现出来的。</strong></p>
<p>多态也称为<em>动态绑定</em>或<em>后期绑定</em>或<em>运行时绑定</em>）。</p>
<h3 id="向上转型回顾"><a href="#向上转型回顾" class="headerlink" title="向上转型回顾"></a>向上转型回顾</h3><p>把一个对象引用当作它的基类引用的做法称为向上转型，因为继承图中基类一般都位于最上方。</p>
<p>只写一个方法以基类作为参数，而不用管是哪个具体派生类。</p>
<pre><code class="java">package polymorphism.music;
class Instrument &#123;
    public void play(Note n) &#123;
        System.out.println(&quot;Instrument.play()&quot;);
    &#125;
&#125;
public class Wind extends Instrument &#123;
    // Redefine interface method:
    @Override
    public void play(Note n) &#123;
        System.out.println(&quot;Wind.play() &quot; + n);
    &#125;
&#125;public class Music &#123;
    public static void tune(Instrument i) &#123;
        // ...
        i.play(Note.MIDDLE_C);
    &#125;
    public static void main(String[] args) &#123;
        Wind flute = new Wind();
        tune(flute); // Upcasting
    &#125;
&#125;</code></pre>
<h3 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h3><p>将一个方法调用和一个方法主体关联起来称作<em>绑定</em>。</p>
<p><em>前期绑定</em> :若绑定发生在程序运行前（如果有的话，由编译器和链接器实现)。它是面向过程语言不需选择默认的绑定方式，例如在 C 语言中就只有<em>前期绑定</em>这一种方法调用。</p>
<p><em>后期绑定</em>：也称为<em>动态绑定</em>或<em>运行时绑定</em>。编译器仍然不知道对象的类型，但是有 某种机制在运行时能判断对象类型，方法调用机制能找到正确的方法体并调用。</p>
<p>Java 中除了 <strong>static</strong> 和 <strong>final</strong> 方法（<strong>private</strong> 方法也是隐式的 <strong>final</strong>）外，其他所有方法都是后期绑定。这意味着通常情况下，我们不需要判断后期绑定是否会发生——它自动发生。</p>
<pre><code class="java">Shape s = new Circle();
s.draw()
//由于后期绑定（多态）被调用的是 Circle 的 draw() 方法</code></pre>
<ul>
<li><p>陷阱：重写私有方法</p>
<pre><code class="java">package polymorphism;
public class PrivateOverride &#123;
    private void f() &#123;
        System.out.println(&quot;private f()&quot;);
    &#125;
    public static void main(String[] args) &#123;
        PrivateOverride po = new Derived();
        po.f();
    &#125;
&#125;
class Derived extends PrivateOverride &#123;
    public void f() &#123;
        System.out.println(&quot;public f()&quot;);
    &#125;
&#125;</code></pre>
</li>
</ul>
<p>  private 方法可以当作是 final 的，对于派生类来说是隐蔽的。因此，这里 Derived 的 <code>f()</code> 是一个全新的方法；    </p>
<p>  结论是只有非 private 方法才能被重写，但是得小心重写 private 方法的现象，编译器不报错，但不会按我们所预期的执行。如果使用了 <code>@Override</code> 注解，就能检测出问题。</p>
<ul>
<li><p>陷阱：属性与静态方法</p>
<p>只有普通方法调用可以是多态的。属性与静态方法会在访问时进行编译解析。</p>
</li>
</ul>
<ol>
<li><p>属性：</p>
<pre><code class="java">class Super &#123;
 public int field = 0;

 public int getField() &#123;
     return field;
 &#125;
&#125;

class Sub extends Super &#123;
 public int field = 1;

 @Override
 public int getField() &#123;
     return field;
 &#125;

 public int getSuperField() &#123;
     return super.field;
 &#125;
&#125;

public class FieldAccess &#123;
 public static void main(String[] args) &#123;
     Super sup = new Sub(); // Upcast
     System.out.println(&quot;sup.field = &quot; + sup.field + 
                       &quot;, sup.getField() = &quot; + sup.getField());
     Sub sub = new Sub();
     System.out.println(&quot;sub.field = &quot; + sub.field + 
                       &quot;, sub.getField() = &quot; + sub.getField()
                       + &quot;, sub.getSuperField() = &quot; + sub.getSuperField())
 &#125;
&#125;

/* 输出

sup.field = 0, sup.getField() = 1
sub.field = 1, sub.getField() = 1, sub.getSuperField() = 0</code></pre>
</li>
</ol>
<p>  */</p>
<pre><code>


当 Sub 对象向上转型为 Super 引用时，任何属性访问都被编译器解析，因此不是多态的.Super.field 和 Sub.field 被分配了不同的存储空间。为了获取 Super 的 field 属性，需要显式地指明 super.field。实际上，会讲所有属性 指明为private，因此不能 直接访问 ，只能通过方法来进行访问。

2. 静态方法

   静态的方法只与类关联，与单个的对象无关。



### 构造器和多态



在派生类的构造过程中总会调用基类的构造器。初始化会自动按继承层次结构上移，因此每个基类的构造器都会被调用到（为了构造完整的对象）。如果在派生类的构造器主体中没有显式地调用基类构造器，编译器就会默默地调用无参构造器。如果没有无参构造器，编译器就会报错。

```java
package polymorphism;

class Meal &#123;
  Meal() &#123;
      System.out.println(&quot;Meal()&quot;);
  &#125;
&#125;

class Bread &#123;
  Bread() &#123;
      System.out.println(&quot;Bread()&quot;);
  &#125;
&#125;

class Cheese &#123;
  Cheese() &#123;
      System.out.println(&quot;Cheese()&quot;);
  &#125;
&#125;

class Lettuce &#123;
  Lettuce() &#123;
      System.out.println(&quot;Lettuce()&quot;);
  &#125;
&#125;

class Lunch extends Meal &#123;
  Lunch() &#123;
      System.out.println(&quot;Lunch()&quot;);
  &#125;
&#125;

class PortableLunch extends Lunch &#123;
  PortableLunch() &#123;
      System.out.println(&quot;PortableLunch()&quot;);
  &#125;
&#125;

public class Sandwich extends PortableLunch &#123;
  private Bread b = new Bread();
  private Cheese c = new Cheese();
  private Lettuce l = new Lettuce();

  public Sandwich() &#123;
      System.out.println(&quot;Sandwich()&quot;);
  &#125;

  public static void main(String[] args) &#123;
      new Sandwich();
  &#125;
&#125;

/* 输出

Meal()
Lunch()
PortableLunch()
Bread()
Cheese()
Lettuce()
Sandwich()

*/</code></pre>
<p>调用顺序：</p>
<ol>
<li>基类构造器被调用，递归重复。</li>
<li>按声明顺序初始化成员。</li>
<li>调用派生类构造器的方法体。</li>
</ol>
<p>在构造器中必须确保所有的成员都已经构建完。唯一能保证这点的方法就是首先调用基类的构造器。</p>
<p><strong>继承和清理</strong></p>
<p>如果需要其他特殊清理工作，需要设计一个清理方法。当重写清理方法时，记得调用基类的清理方法，否则基类的清理工作不会发生：</p>
<pre><code class="java">// polymorphism/Frog.java
// Cleanup and inheritance
// &#123;java polymorphism.Frog&#125;
package polymorphism;

class Characteristic &#123;
    private String s;

    Characteristic(String s) &#123;
        this.s = s;
        System.out.println(&quot;Creating Characteristic &quot; + s);
    &#125;

    protected void dispose() &#123;
        System.out.println(&quot;disposing Characteristic &quot; + s);
    &#125;
&#125;

class Description &#123;
    private String s;

    Description(String s) &#123;
        this.s = s;
        System.out.println(&quot;Creating Description &quot; + s);
    &#125;

    protected void dispose() &#123;
        System.out.println(&quot;disposing Description &quot; + s);
    &#125;
&#125;

class LivingCreature &#123;
    private Characteristic p = new Characteristic(&quot;is alive&quot;);
    private Description t = new Description(&quot;Basic Living Creature&quot;);

    LivingCreature() &#123;
        System.out.println(&quot;LivingCreature()&quot;);
    &#125;

    protected void dispose() &#123;
        System.out.println(&quot;LivingCreature dispose&quot;);
        t.dispose();
        p.dispose();
    &#125;
&#125;

class Animal extends LivingCreature &#123;
    private Characteristic p = new Characteristic(&quot;has heart&quot;);
    private Description t = new Description(&quot;Animal not Vegetable&quot;);

    Animal() &#123;
        System.out.println(&quot;Animal()&quot;);
    &#125;

    @Override
    protected void dispose() &#123;
        System.out.println(&quot;Animal dispose&quot;);
        t.dispose();
        p.dispose();
        super.dispose();
    &#125;
&#125;

class Amphibian extends Animal &#123;
    private Characteristic p = new Characteristic(&quot;can live in water&quot;);
    private Description t = new Description(&quot;Both water and land&quot;);

    Amphibian() &#123;
        System.out.println(&quot;Amphibian()&quot;);
    &#125;

    @Override
    protected void dispose() &#123;
        System.out.println(&quot;Amphibian dispose&quot;);
        t.dispose();
        p.dispose();
        super.dispose();
    &#125;
&#125;

public class Frog extends Amphibian &#123;
    private Characteristic p = new Characteristic(&quot;Croaks&quot;);
    private Description t = new Description(&quot;Eats Bugs&quot;);

    public Frog() &#123;
        System.out.println(&quot;Frog()&quot;);
    &#125;

    @Override
    protected void dispose() &#123;
        System.out.println(&quot;Frog dispose&quot;);
        t.dispose();
        p.dispose();
        super.dispose();
    &#125;

    public static void main(String[] args) &#123;
        Frog frog = new Frog();
        System.out.println(&quot;Bye!&quot;);
        frog.dispose();
    &#125;
&#125;</code></pre>
<pre><code class="java">Creating Characteristic is alive
Creating Description Basic Living Creature
LivingCreature()
Creating Characteristiv has heart
Creating Description Animal not Vegetable
Animal()
Creating Characteristic can live in water
Creating Description Both water and land
Amphibian()
Creating Characteristic Croaks
Creating Description Eats Bugs
Frog()
Bye!
Frog dispose
disposing Description Eats Bugs
disposing Characteristic Croaks
Amphibian dispose
disposing Description Both wanter and land
disposing Characteristic can live in water
Animal dispose
disposing Description Animal not Vegetable
disposing Characteristic has heart
LivingCreature dispose
disposing Description Basic Living Creature
disposing Characteristic is alive</code></pre>
<p>先进行派生类的清理工作，然后才是基类的清理。</p>
<p>然而，一旦某个成员对象被其它一个或多个对象共享时，问题就变得复杂了，不能只是简单地调用 <code>dispose()</code>。这里，也许就必须使用<em>引用计数</em>来跟踪仍然访问着共享对象的对象数量，如下：</p>
<pre><code class="java">class Shared &#123;
    private int refcount = 0;
    private static long counter = 0;
    private final long id = counter++;

    Shared() &#123;
        System.out.println(&quot;Creating &quot; + this);
    &#125;

    public void addRef() &#123;
        refcount++;
    &#125;

    protected void dispose() &#123;
        if (--refcount == 0) &#123;
            System.out.println(&quot;Disposing &quot; + this);
        &#125;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;Shared &quot; + id;
    &#125;
&#125;

class Composing &#123;
    private Shared shared;
    private static long counter = 0;
    private final long id = counter++;

    Composing(Shared shared) &#123;
        System.out.println(&quot;Creating &quot; + this);
        this.shared = shared;
        this.shared.addRef();
    &#125;

    protected void dispose() &#123;
        System.out.println(&quot;disposing &quot; + this);
        shared.dispose();
    &#125;

    @Override
    public String toString() &#123;
        return &quot;Composing &quot; + id;
    &#125;
&#125;

public class ReferenceCounting &#123;
    public static void main(String[] args) &#123;
        Shared shared = new Shared();
        Composing[] composing = &#123;
            new Composing(shared),
            new Composing(shared),
            new Composing(shared),
            new Composing(shared),
            new Composing(shared),
        &#125;;
        for (Composing c: composing) &#123;
            c.dispose();
        &#125;
    &#125;
&#125;</code></pre>
<p>输出：</p>
<pre><code class="j">Creating Shared 0
Creating Composing 0
Creating Composing 1
Creating Composing 2
Creating Composing 3
Creating Composing 4
disposing Composing 0
disposing Composing 1
disposing Composing 2
disposing Composing 3
disposing Composing 4
Disposing Shared 0</code></pre>
<p>在将一个 shared 对象附着在类上时，必须记住调用 <code>addRef()</code>，而 <code>dispose()</code> 方法会跟踪引用数，以确定在何时真正地执行清理工作。</p>
<p><strong>构造器内部多态方法的行为</strong></p>
<p>如果在构造器中调用了正在构造的对象的动态绑定方法，该方法操纵的成员可能还没有初始化——这肯定会带来灾难。</p>
<pre><code class="java">// polymorphism/PolyConstructors.java
// Constructors and polymorphism
// don&#39;t produce what you might expect
class Glyph &#123;
    void draw() &#123;
        System.out.println(&quot;Glyph.draw()&quot;);
    &#125;

    Glyph() &#123;
        System.out.println(&quot;Glyph() before draw()&quot;);
        draw();
        System.out.println(&quot;Glyph() after draw()&quot;);
    &#125;
&#125;

class RoundGlyph extends Glyph &#123;
    private int radius = 1;

    RoundGlyph(int r) &#123;
        radius = r;
        System.out.println(&quot;RoundGlyph.RoundGlyph(), radius = &quot; + radius);
    &#125;

    @Override
    void draw() &#123;
        System.out.println(&quot;RoundGlyph.draw(), radius = &quot; + radius);
    &#125;
&#125;

public class PolyConstructors &#123;
    public static void main(String[] args) &#123;
        new RoundGlyph(5);
    &#125;
&#125;</code></pre>
<pre><code>Glyph() before draw()
RoundGlyph.draw(), radius = 0
Glyph() after draw()
RoundGlyph.RoundGlyph(), radius = 5</code></pre>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h3 id="协变返回类型"><a href="#协变返回类型" class="headerlink" title="协变返回类型"></a>协变返回类型</h3><p>派生类的被重写方法可以返回基类方法返回类型的派生类型：</p>
<pre><code class="java">// polymorphism/CovariantReturn.java
class Grain &#123;
    @Override
    public String toString() &#123;
        return &quot;Grain&quot;;
    &#125;
&#125;

class Wheat extends Grain &#123;
    @Override
    public String toString() &#123;
        return &quot;Wheat&quot;;
    &#125;
&#125;

class Mill &#123;
    Grain process() &#123;
        return new Grain();
    &#125;
&#125;

class WheatMill extends Mill &#123;
    @Override
    Wheat process() &#123;
        return new Wheat();
    &#125;
&#125;

public class CovariantReturn &#123;
    public static void main(String[] args) &#123;
        Mill m = new Mill();
        Grain g = m.process();
        System.out.println(g);
        m = new WheatMill();
        g = m.process();
        System.out.println(g);
    &#125;
&#125;</code></pre>
<pre><code>Grain
Wheat</code></pre>
<h3 id="使用继承设计"><a href="#使用继承设计" class="headerlink" title="使用继承设计"></a>使用继承设计</h3><p>组合更灵活，因为可以动态地选择类型，而继承要求必须在编译时知道确切类型。</p>
<pre><code class="java">// polymorphism/Transmogrify.java
// Dynamically changing the behavior of an object
// via composition (the &quot;State&quot; design pattern)
class Actor &#123;
    public void act() &#123;&#125;
&#125;

class HappyActor extends Actor &#123;
    @Override
    public void act() &#123;
        System.out.println(&quot;HappyActor&quot;);
    &#125;
&#125;

class SadActor extends Actor &#123;
    @Override
    public void act() &#123;
        System.out.println(&quot;SadActor&quot;);
    &#125;
&#125;

class Stage &#123;
    private Actor actor = new HappyActor();

    public void change() &#123;
        actor = new SadActor();
    &#125;

    public void performPlay() &#123;
        actor.act();
    &#125;
&#125;

public class Transmogrify &#123;
    public static void main(String[] args) &#123;
        Stage stage = new Stage();
        stage.performPlay();
        stage.change();
        stage.performPlay();
    &#125;
&#125;</code></pre>
<pre><code>HappyActor
SadActor</code></pre>
<p>由于向上转型（在继承层次中向上移动）会丢失具体的类型信息，那么为了重新获取类型信息，就需要在继承层次中向下移动，使用<em>向下转型</em>。</p>
<p>向上转型永远是安全的，因为基类不会具有比派生类更多的接口。</p>
<p>但是对于向下转型，容易出错。</p>
<p>在 Java 中，每次转型都会被检查！所以即使只是进行一次普通的加括号形式的类型转换，在运行时这个转换仍会被检查，以确保它的确是希望的那种类型。如果不是，就会得到 ClassCastException （类转型异常）。这种在运行时检查类型的行为称作运行时类型信息。下面例子展示了 RTTI 的行为：</p>
<pre><code class="java">// polymorphism/RTTI.java
// Downcasting &amp; Runtime type information (RTTI)
// &#123;ThrowsException&#125;
class Useful &#123;
    public void f() &#123;&#125;
    public void g() &#123;&#125;
&#125;

class MoreUseful extends Useful &#123;
    @Override
    public void f() &#123;&#125;
    @Override
    public void g() &#123;&#125;
    public void u() &#123;&#125;
    public void v() &#123;&#125;
    public void w() &#123;&#125;
&#125;

public class RTTI &#123;
    public static void main(String[] args) &#123;
        Useful[] x = &#123;
            new Useful(),
            new MoreUseful()
        &#125;;
        x[0].f();
        x[1].g();
        // Compile time: method not found in Useful:
        //- x[1].u();
        ((MoreUseful) x[1]).u(); // Downcast/RTTI
        ((MoreUseful) x[0]).u(); // Exception thrown
    &#125;
&#125;</code></pre>
<pre><code>Exception in thread &quot;main&quot;
java.lang.ClassCastException: Useful cannot be cast to
MoreUseful
at RTTI.main</code></pre>
<p>RTTI 不仅仅包括简单的转型。例如，它还提供了一种方法，使你可以在试图向下转型前检查所要处理的类型。</p>
<hr>
<h2 id="第十章接口"><a href="#第十章接口" class="headerlink" title="第十章接口"></a>第十章接口</h2><p>接口和抽象类提供了一种将接口与实现分离的更加结构化的方法。</p>
<h3 id="抽象类和方法"><a href="#抽象类和方法" class="headerlink" title="抽象类和方法"></a>抽象类和方法</h3><p>抽象方法的声明语法：</p>
<pre><code class="java">abstract void f();</code></pre>
<p>包含抽象方法的类叫做<em>抽象类</em>。如果一个类包含一个或多个抽象方法，那么类本身也必须限定为抽象的，否则 ，编译器会报错。</p>
<p>如果创建一个继承抽象类的新类并为之创建对象，那么就必须为基类的所有抽象方法提供方法定义。如果不这么做（可以选择不做），新类仍然是一个抽象类，编译器会强制我们为新类加上 <strong>abstract</strong> 关键字。</p>
<p>为了创建可初始化的类，就要继承抽象类，并提供所有抽象方法的定义：</p>
<pre><code class="java">// interfaces/Instantiable.java
abstract class Uninstantiable &#123;
    abstract void f();
    abstract int g();
&#125;

public class Instantiable extends Uninstantiable &#123;
    @Override
    void f() &#123;
        System.out.println(&quot;f()&quot;);
    &#125;

    @Override
    int g() &#123;
        return 22;
    &#125;

    public static void main(String[] args) &#123;
        Uninstantiable ui = new Instantiable();
    &#125;
&#125;</code></pre>
<p>留意 <code>@Override</code> 的使用。没有这个注解的话，如果你没有定义相同的方法名或签名，抽象机制会认为你没有实现抽象方法从而产生编译时错误。</p>
<p>接口只允许 public方法，如果不加访问修饰符的话，接口的方法不是friendly而是public</p>
<p>private abstract是不合法的，是没有意义的。</p>
<pre><code class="java">// interfaces/AbstractAccess.java
abstract class AbstractAccess &#123;
    private void m1() &#123;&#125;

    // private abstract void m1a(); // illegal

    protected void m2() &#123;&#125;

    protected abstract void m2a();

    void m3() &#123;&#125;

    abstract void m3a();

    public void m4() &#123;&#125;

    public abstract void m4a();
&#125;</code></pre>
<p>将一个类指明为 <strong>abstract</strong> 并不强制类中的所有方法必须都是抽象方法。创建抽象类和抽象方法是有帮助的，因为它们使得类的抽象性很明确，并能告知用户和编译器使用意图。抽象类同时也是一种有用的重构工具，使用它们使得我们很容易地将沿着继承层级结构上移公共方法。</p>
<h3 id="接口创建"><a href="#接口创建" class="headerlink" title="接口创建"></a>接口创建</h3><p><strong>interface</strong> 关键字产生一个完全抽象的类，没有提供任何实现</p>
<p>接口被用来建立类之间的协议。</p>
<p>Java 8 允许接口包含<em>默认方法</em>和<em>静态方法</em></p>
<p>接口介于类型之上、实现之下。</p>
<p>接口的典型使用是代表一个类的类型或一个形容词，如 Runnable 或 Serializable，而抽象类通常是类层次结构的一部分或一件事物的类型，如 String 或 ActionHero。</p>
<pre><code class="java">// interfaces/ImplementingAnInterface.java
interface Concept &#123; // Package access
    void idea1();
    void idea2();
&#125;

class Implementation implements Concept &#123;
    @Override
    public void idea1() &#123;
        System.out.println(&quot;idea1&quot;);
    &#125;

    @Override
    public void idea2() &#123;
        System.out.println(&quot;idea2&quot;);
    &#125;
&#125;</code></pre>
<p>可选择显式地声明接口中的方法为 <strong>public</strong>，不显式声明，默认也是 <strong>public</strong> 的。所以当实现一个接口时，来自接口中的方法必须被定义为 <strong>public</strong>。否则，它们只有包访问权限，这样在继承时，它们的可访问权限就被降低了，这是 Java 编译器所不允许的。</p>
<p>默认方法：default</p>
<p>​    当在接口中使用它时，任何实现接口却没有定义方法的时候可以使用 <strong>default</strong> 创建的方法体</p>
<pre><code class="java">// interfaces/InterfaceWithDefault.java
interface InterfaceWithDefault &#123;
    void firstMethod();
    void secondMethod();

    default void newMethod() &#123;
        System.out.println(&quot;newMethod&quot;);
    &#125;
&#125;</code></pre>
<pre><code class="java">// interfaces/Implementation2.java
public class Implementation2 implements InterfaceWithDefault &#123;
    @Override
    public void firstMethod() &#123;
        System.out.println(&quot;firstMethod&quot;);
    &#125;

    @Override
    public void secondMethod() &#123;
        System.out.println(&quot;secondMethod&quot;)
    &#125;

    public static void main(String[] args) &#123;
        InterfaceWithDefault i = new Implementation2();
        i.firstMethod();
        i.secondMethod();
        i.newMethod();
    &#125;
&#125;

/* 输出

firstMethod
secondMethod
newMethod
*/
</code></pre>
<p>增加默认方法的极具说服力的理由是它允许在不破坏已使用接口的代码的情况下，在接口中增加新的方法。默认方法有时也被称为<em>守卫方法</em>或<em>虚拟扩展方法</em>。</p>
<p>多继承问题</p>
<p>Java 过去是一种严格要求单继承的语言：只能继承自一个类（或抽象类），但可以实现任意多个接口。</p>
<p>现在Java 通过默认方法具有了某种多继承的特性。结合带有默认方法的接口意味着结合了多个基类中的行为。因为接口中仍然不允许存在属性（只有静态属性，不适用），所以属性仍然只会来自单个基类或抽象类，也就是说，不会存在状态的多继承。</p>
<pre><code class="java">// interfaces/MultipleInheritance.java
import java.util.*;

interface One &#123;
    default void first() &#123;
        System.out.println(&quot;first&quot;);
    &#125;
&#125;

interface Two &#123;
    default void second() &#123;
        System.out.println(&quot;second&quot;);
    &#125;
&#125;

interface Three &#123;
    default void third() &#123;
        System.out.println(&quot;third&quot;);
    &#125;
&#125;

class MI implements One, Two, Three &#123;&#125;

public class MultipleInheritance &#123;
    public static void main(String[] args) &#123;
        MI mi = new MI();
        mi.first();
        mi.second();
        mi.third();
    &#125;
&#125;</code></pre>
<pre><code>first
second
third</code></pre>
<p>结合多个源的实现。只要基类方法中的方法名和参数列表（签名）不同，就能工作得很好，否则会得到编译器错误：</p>
<pre><code class="java">// interface/MICollision.java
import java.util.*;

interface Bob1 &#123;
    default void bob() &#123;
        System.out.println(&quot;Bob1::bob&quot;);
    &#125;
&#125;

interface Bob2 &#123;
    default void bob() &#123;
        System.out.println(&quot;Bob2::bob&quot;);
    &#125;
&#125;

// class Bob implements Bob1, Bob2 &#123;&#125;
/* Produces:
error: class Bob inherits unrelated defaults
for bob() from types Bob1 and Bob2
class Bob implements Bob1, Bob2 &#123;&#125;
^
1 error
*/

interface Sam1 &#123;
    default void sam() &#123;
        System.out.println(&quot;Sam1::sam&quot;);
    &#125;
&#125;

interface Sam2 &#123;
    default void sam(int i) &#123;
        System.out.println(i * 2);
    &#125;
&#125;

// This works because the argument lists are distinct:
class Sam implements Sam1, Sam2 &#123;&#125;

interface Max1 &#123;
    default void max() &#123;
        System.out.println(&quot;Max1::max&quot;);
    &#125;
&#125;

interface Max2 &#123;
    default int max() &#123;
        return 47;
    &#125;
&#125;

// class Max implements Max1, Max2 &#123;&#125;
/* Produces:
error: types Max2 and Max1 are imcompatible;
both define max(), but with unrelated return types
class Max implements Max1, Max2 &#123;&#125;
^
1 error
*/</code></pre>
<p>为了解决上述多问题，需要覆写冲突的方法：</p>
<pre><code class="java">// interfaces/Jim.java
import java.util.*;

interface Jim1 &#123;
    default void jim() &#123;
        System.out.println(&quot;Jim1::jim&quot;);
    &#125;
&#125;

interface Jim2 &#123;
    default void jim() &#123;
        System.out.println(&quot;Jim2::jim&quot;);
    &#125;
&#125;

public class Jim implements Jim1, Jim2 &#123;
    @Override
    public void jim() &#123;
        Jim2.super.jim();
    &#125;

    public static void main(String[] args) &#123;
        new Jim().jim();
    &#125;
&#125;</code></pre>
<pre><code>Jim2::jim</code></pre>
<p>接口中的静态方法</p>
<pre><code class="java">// onjava/Operations.java
package onjava;
import java.util.*;

public interface Operations &#123;
    void execute();

    static void runOps(Operations... ops) &#123;
        for (Operations op: ops) &#123;
            op.execute();
        &#125;
    &#125;

    static void show(String msg) &#123;
        System.out.println(msg);
    &#125;
&#125;</code></pre>
<p><code>runOps()</code> 是一个模版方法。<code>runOps()</code> 使用可变参数列表，因而我们可以传入任意多的 Operation 参数并按顺序运行它们：</p>
<pre><code class="java">// interface/Machine.java
import java.util.*;
import onjava.Operations;

class Bing implements Operations &#123;
    @Override
    public void execute() &#123;
        Operations.show(&quot;Bing&quot;);
    &#125;
&#125;

class Crack implements Operations &#123;
    @Override
    public void execute() &#123;
        Operations.show(&quot;Crack&quot;);
    &#125;
&#125;

class Twist implements Operations &#123;
    @Override
    public void execute() &#123;
        Operations.show(&quot;Twist&quot;);
    &#125;
&#125;

public class Machine &#123;
    public static void main(String[] args) &#123;
        Operations.runOps(
            new Bing(), new Crack(), new Twist());
    &#125;
&#125;
/* 输出
Bing
Crack
Twist

*/</code></pre>
<p>接口的工作方式使得我们不需要显式声明其中的方法为 <strong>public</strong>，它们自动就是 <strong>public</strong> 的。</p>
<pre><code class="java">// interfaces/music5/Music5.java
// &#123;java interfaces.music5.Music5&#125;
package interfaces.music5;
import polymorphism.music.Note;

interface Instrument &#123;
    // Compile-time constant:
    int VALUE = 5; // static &amp; final

    default void play(Note n)  // Automatically public 
        System.out.println(this + &quot;.play() &quot; + n);
    &#125;

    default void adjust() &#123;
        System.out.println(&quot;Adjusting &quot; + this);
    &#125;
&#125;

class Wind implements Instrument &#123;
    @Override
    public String toString() &#123;
        return &quot;Wind&quot;;
    &#125;
&#125;

class Percussion implements Instrument &#123;
    @Override
    public String toString() &#123;
        return &quot;Percussion&quot;;
    &#125;
&#125;

class Stringed implements Instrument &#123;
    @Override
    public String toString() &#123;
        return &quot;Stringed&quot;;
    &#125;
&#125;

class Brass extends Wind &#123;
    @Override
    public String toString() &#123;
        return &quot;Brass&quot;;
    &#125;
&#125;

class Woodwind extends Wind &#123;
    @Override
    public String toString() &#123;
        return &quot;Woodwind&quot;;
    &#125;
&#125;

public class Music5 &#123;
    // Doesn&#39;t care about type, so new types
    // added to the system still work right:
    static void tune(Instrument i) &#123;
        // ...
        i.play(Note.MIDDLE_C);
    &#125;

    static void tuneAll(Instrument[] e) &#123;
        for (Instrument i: e) &#123;
            tune(i);
        &#125;
    &#125;

    public static void main(String[] args) &#123;
        // Upcasting during addition to the array:
        Instrument[] orchestra = &#123;
            new Wind(),
            new Percussion(),
            new Stringed(),
            new Brass(),
            new Woodwind()
        &#125;
        tuneAll(orchestra);
    &#125;
&#125;
</code></pre>
<pre><code>Wind.play() MIDDLE_C
Percussion.play() MIDDLE_C
Stringed.play() MIDDLE_C
Brass.play() MIDDLE_C
Woodwind.play() MIDDLE_C</code></pre>
<h3 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h3><table>
<thead>
<tr>
<th>特性</th>
<th>接口</th>
<th>抽象类</th>
</tr>
</thead>
<tbody><tr>
<td>组合</td>
<td>新类可以组合多个接口</td>
<td>只能继承单一抽象类</td>
</tr>
<tr>
<td>状态</td>
<td>不能包含属性（除了静态属性，不支持对象状态）</td>
<td>可以包含属性，非抽象方法可能引用这些属性</td>
</tr>
<tr>
<td>默认方法 和 抽象方法</td>
<td>不需要在子类中实现默认方法。默认方法可以引用其他接口的方法</td>
<td>必须在子类中实现抽象方法</td>
</tr>
<tr>
<td>构造器</td>
<td>没有构造器</td>
<td>可以有构造器</td>
</tr>
<tr>
<td>可见性</td>
<td>隐式 <strong>public</strong></td>
<td>可以是 <strong>protected</strong> 或友元</td>
</tr>
</tbody></table>
<p>抽象类仍然是一个类，在创建新类时只能继承它一个。而创建类的过程中可以实现多个接口。</p>
<p>有一条实际经验：尽可能地抽象。因此，更倾向使用接口而不是抽象类。</p>
<h3 id="完全解耦"><a href="#完全解耦" class="headerlink" title="完全解耦"></a>完全解耦</h3><pre><code class="java">// interfaces/Applicator.java
import java.util.*;

class Processor &#123;
    public String name() &#123;
        return getClass().getSimpleName();
    &#125;

    public Object process(Object input) &#123;
        return input;
    &#125;
&#125;

class Upcase extends Processor &#123;
    // 返回协变类型
    @Override 
    public String process(Object input) &#123;
        return ((String) input).toUpperCase();
    &#125;
&#125;

class Downcase extends Processor &#123;
    @Override
    public String process(Object input) &#123;
        return ((String) input).toLowerCase();
    &#125;
&#125;

class Splitter extends Processor &#123;
    @Override
    public String process(Object input) &#123;
        // split() divides a String into pieces:
        return Arrays.toString(((String) input).split(&quot; &quot;));
    &#125;
&#125;

public class Applicator &#123;
    public static void apply(Processor p, Object s) &#123;
        System.out.println(&quot;Using Processor &quot; + p.name());
        System.out.println(p.process(s));
    &#125;

    public static void main(String[] args) &#123;
        String s = &quot;We are such stuff as dreams are made on&quot;;
        apply(new Upcase(), s);
        apply(new Downcase(), s);
        apply(new Splitter(), s);
    &#125;
&#125;</code></pre>
<pre><code>Using Processor Upcase
WE ARE SUCH STUFF AS DREAMS ARE MADE ON
Using Processor Downcase
we are such stuff as dreams are made on
Using Processor Splitter
[We, are, such, stuff, as, dreams, are, made, on]</code></pre>
<p>Applicator 的 <code>apply()</code> 方法可以接受任何类型的 Processor，并将其应用到一个 Object 对象上输出结果。创建一个能根据传入的参数类型从而具备不同行为的方法称为<em>策略</em>设计模式。策略就是传入的对象，它包含要执行的代码。</p>
<h3 id="多接口结合"><a href="#多接口结合" class="headerlink" title="多接口结合"></a>多接口结合</h3><pre><code class="java">// interfaces/Adventure.java
// Multiple interfaces
interface CanFight &#123;
    void fight();
&#125;

interface CanSwim &#123;
    void swim();
&#125;

interface CanFly &#123;
    void fly();
&#125;

class ActionCharacter &#123;
    public void fight()&#123;&#125;
&#125;

class Hero extends ActionCharacter implements CanFight, CanSwim, CanFly &#123;
    public void swim() &#123;&#125;

    public void fly() &#123;&#125;
&#125;

public class Adventure &#123;
    public static void t(CanFight x) &#123;
        x.fight();
    &#125;

    public static void u(CanSwim x) &#123;
        x.swim();
    &#125;

    public static void v(CanFly x) &#123;
        x.fly();
    &#125;

    public static void w(ActionCharacter x) &#123;
        x.fight();
    &#125;

    public static void main(String[] args) &#123;
        Hero h = new Hero();
        t(h); // Treat it as a CanFight
        u(h); // Treat it as a CanSwim
        v(h); // Treat it as a CanFly
        w(h); // Treat it as an ActionCharacter
    &#125;
&#125;</code></pre>
<p>类 Hero 结合了具体类 ActionCharacter 和接口 CanFight、CanSwim 和 CanFly。当通过这种方式结合具体类和接口时，需要将具体类放在前面，后面跟着接口（否则编译器会报错）。</p>
<h3 id="使用继承扩展接口"><a href="#使用继承扩展接口" class="headerlink" title="使用继承扩展接口"></a>使用继承扩展接口</h3><p>通过继承，可以很容易在接口中增加方法声明，还可以在新接口中结合多个接口。这两种情况都可以得到新接口，如下例所示：</p>
<pre><code class="java">// interfaces/HorrorShow.java
// Extending an interface with inheritance
interface Monster &#123;
    void menace();
&#125;

interface DangerousMonster extends Monster &#123;
    void destroy();
&#125;

interface Lethal &#123;
    void kill();
&#125;

class DragonZilla implements DangerousMonster &#123;
    @Override
    public void menace() &#123;&#125;

    @Override
    public void destroy() &#123;&#125;
&#125;

interface Vampire extends DangerousMonster, Lethal &#123;
    void drinkBlood();
&#125;

class VeryBadVampire implements Vampire &#123;
    @Override
    public void menace() &#123;&#125;

    @Override
    public void destroy() &#123;&#125;

    @Override
    public void kill() &#123;&#125;

    @Override
    public void drinkBlood() &#123;&#125;
&#125;

public class HorrorShow &#123;
    static void u(Monster b) &#123;
        b.menace();
    &#125;

    static void v(DangerousMonster d) &#123;
        d.menace();
        d.destroy();
    &#125;

    static void w(Lethal l) &#123;
        l.kill();
    &#125;

    public static void main(String[] args) &#123;
        DangerousMonster barney = new DragonZilla();
        u(barney);
        v(barney);
        Vampire vlad = new VeryBadVampire();
        u(vlad);
        v(vlad);
        w(vlad);
    &#125;
&#125;</code></pre>
<p>结合接口时的命名冲突</p>
<pre><code class="java">// interfaces/InterfaceCollision.java
interface I1 &#123;
    void f();
&#125;

interface I2 &#123;
    int f(int i);
&#125;

interface I3 &#123;
    int f();
&#125;

class C &#123;
    public int f() &#123;
        return 1;
    &#125;
&#125;

class C2 implements I1, I2 &#123;
    @Override
    public void f() &#123;&#125;

    @Override
    public int f(int i) &#123;
        return 1;  // 重载
    &#125;
&#125;

class C3 extends C implements I2 &#123;
    @Override
    public int f(int i) &#123;
        return 1; // 重载
    &#125;
&#125;

class C4 extends C implements I3 &#123;
    // 完全相同，没问题
    @Override
    public int f() &#123;
        return 1;
    &#125;
&#125;

// 方法的返回类型不同
//- class C5 extends C implements I1 &#123;&#125;
//- interface I4 extends I1, I3 &#123;&#125;</code></pre>
<p>覆写、实现和重载令人不快地搅和在一起带来了困难。同时，重载方法仅根据返回类型是区分不了的。</p>
<h3 id="接口适配"><a href="#接口适配" class="headerlink" title="接口适配"></a>接口适配</h3><p>接口最吸引人的原因之一是相同的接口可以有多个实现。在简单情况下体现在一个方法接受接口作为参数，该接口的实现和传递对象则取决于方法的使用者。</p>
<p>因此，接口的一种常见用法是前面提到的<em>策略</em>设计模式。编写一个方法执行某些操作并接受一个指定的接口作为参数。可以说：“只要对象遵循接口，就可以调用方法” ，这使得方法更加灵活，通用，并更具可复用性。</p>
<h3 id="接口字段"><a href="#接口字段" class="headerlink" title="接口字段"></a>接口字段</h3><p>因为接口中的字段都自动是 <strong>static</strong> 和 <strong>final</strong> 的，所以接口就成为了创建一组常量的方便的工具。</p>
<p>接口中定义的字段不能是“空 <strong>final</strong>“，但是可以用非常量表达式初始化。例如</p>
<pre><code class="java">// interfaces/RandVals.java
// Initializing interface fields with
// non-constant initializers
import java.util.*;

public interface RandVals &#123;
    Random RAND = new Random(47);
    int RANDOM_INT = RAND.nextInt(10);
    long RANDOM_LONG = RAND.nextLong() * 10;
    float RANDOM_FLOAT = RAND.nextLong() * 10;
    double RANDOM_DOUBLE = RAND.nextDouble() * 10;
&#125;</code></pre>
<p>因为字段是 <strong>static</strong> 的，所以它们在类第一次被加载时初始化，这发生在任何字段首次被访问时。下面是个简单的测试：</p>
<pre><code class="java">// interfaces/TestRandVals.java
public class TestRandVals &#123;
    public static void main(String[] args) &#123;
        System.out.println(RandVals.RANDOM_INT);
        System.out.println(RandVals.RANDOM_LONG);
        System.out.println(RandVals.RANDOM_FLOAT);
        System.out.println(RandVals.RANDOM_DOUBLE);
    &#125;
&#125;
/* 输出
8
-32032247016559954
-8.5939291E18
5.779976127815049
*/</code></pre>
<p>这些字段不是接口的一部分，它们的值被存储在接口的静态存储区域中。</p>
<h3 id="接口嵌套"><a href="#接口嵌套" class="headerlink" title="接口嵌套"></a>接口嵌套</h3><p>接口可以嵌套在类或其他接口中。</p>
<p>在类中嵌套接口的语法是相当显而易见的。就像非嵌套接口一样，它们具有 public 或包访问权限的可见性。</p>
<pre><code class="java">// interfaces/nesting/NestingInterfaces.java
// &#123;java interfaces.nesting.NestingInterfaces&#125;
package interfaces.nesting;

class A &#123;
    interface B &#123;
        void f();
    &#125;

    public class BImp implements B &#123;
        @Override
        public void f() &#123;&#125;
    &#125;

    public class BImp2 implements B &#123;
        @Override
        public void f() &#123;&#125;
    &#125;

    public interface C &#123;
        void f();
    &#125;

    class CImp implements C &#123;
        @Override
        public void f() &#123;&#125;
    &#125;

    private class CImp2 implements C &#123;
        @Override
        public void f() &#123;&#125;
    &#125;

    private interface D &#123;
        void f();
    &#125;

    private class DImp implements D &#123;
        @Override
        public void f() &#123;&#125;
    &#125;

    public class DImp2 implements D &#123;
        @Override
        public void f() &#123;&#125;
    &#125;

    public D getD() &#123;
        return new DImp2();
    &#125;

    private D dRef;

    public void receiveD(D d) &#123;
        dRef = d;
        dRef.f();
    &#125;
&#125;

//接口之间也可以嵌套。接口中的元素必须是 public 的，自动，不能 指明为private。
interface E &#123;
    interface G &#123;
        void f();
    &#125;
    // Redundant &quot;public&quot;
    public interface H &#123;
        void f();
    &#125;

    void g();
    // Cannot be private within an interface
    //- private interface I &#123;&#125;
&#125;


//类 NestingInterfaces 展示了嵌套接口的不同实现方式。尤其是当实现某个接口时，并不需要实现嵌套在其内部的接口。同时，private 接口不能在定义它的类之外被实现。
public class NestingInterfaces &#123;
    public class BImp implements A.B &#123;
        @Override
        public void f() &#123;&#125;
    &#125;

    class CImp implements A.C &#123;
        @Override
        public void f() &#123;&#125;
    &#125;
    // Cannot implements a private interface except
    // within that interface&#39;s defining class:
    //- class DImp implements A.D &#123;
    //- public void f() &#123;&#125;
    //- &#125;
    class EImp implements E &#123;
        @Override
        public void g() &#123;&#125;
    &#125;

    class EGImp implements E.G &#123;
        @Override
        public void f() &#123;&#125;
    &#125;

    class EImp2 implements E &#123;
        @Override
        public void g() &#123;&#125;

        class EG implements E.G &#123;
            @Override
            public void f() &#123;&#125;
        &#125;
    &#125;

    public static void main(String[] args) &#123;
        A a = new A();
        // Can&#39;t access to A.D:
        //- A.D ad = a.getD();
        // Doesn&#39;t return anything but A.D:
        //- A.DImp2 di2 = a.getD();
        // cannot access a member of the interface:
        //- a.getD().f();
        // Only another A can do anything with getD():
        A a2 = new A();
        a2.receiveD(a.getD());
    &#125;
&#125;</code></pre>
<p>作为一种新添加的方式，接口也可以是 private 的，例如 A.D。 private 嵌套接口用来实现一个 private 内部类。</p>
<h3 id="接口和工厂方法模式"><a href="#接口和工厂方法模式" class="headerlink" title="接口和工厂方法模式"></a>接口和工厂方法模式</h3><p>接口是多实现的途径，而生成符合某个接口的对象的典型方式是<em>工厂方法</em>设计模式。不同于直接调用构造器，只需调用工厂对象中的创建方法就能生成对象的实现——理论上，通过这种方式可以将接口与实现的代码完全分离，使得可以透明地将某个实现替换为另一个实现。这里是一个展示工厂方法结构的例子：</p>
<pre><code class="java">// interfaces/Factories.java
interface Service &#123;
    void method1();
    void method2();
&#125;

interface ServiceFactory &#123;
    Service getService();
&#125;

class Service1 implements Service &#123;
    Service1() &#123;&#125; // Package access

    @Override
    public void method1() &#123;
        System.out.println(&quot;Service1 method1&quot;);
    &#125;

    @Override
    public void method2() &#123;
        System.out.println(&quot;Service1 method2&quot;);
    &#125;
&#125;

class Service1Factory implements ServiceFactory &#123;
    @Override
    public Service getService() &#123;
        return new Service1();
    &#125;
&#125;

class Service2 implements Service &#123;
    Service2() &#123;&#125; // Package access

    @Override
    public void method1() &#123;
        System.out.println(&quot;Service2 method1&quot;);
    &#125;

    @Override
    public void method2() &#123;
        System.out.println(&quot;Service2 method2&quot;);
    &#125;
&#125;

class Service2Factory implements ServiceFactory &#123;
    @Override
    public Service getService() &#123;
        return new Service2();
    &#125;
&#125;

public class Factories &#123;
    public static void serviceConsumer(ServiceFactory fact) &#123;
        Service s = fact.getService();
        s.method1();
        s.method2();
    &#125;

    public static void main(String[] args) &#123;
        serviceConsumer(new Service1Factory());
        // Services are completely interchangeable:
        serviceConsumer(new Service2Factory());
    &#125;
&#125;</code></pre>
<pre><code>Service1 method1
Service1 method2
Service2 method1
Service2 method2</code></pre>
<p>如果没有工厂方法，代码就必须在某处指定将要创建的 <strong>Service</strong> 的确切类型，从而调用恰当的构造器。</p>
<hr>
<h2 id="第十一章"><a href="#第十一章" class="headerlink" title="第十一章"></a>第十一章</h2><blockquote>
<p>一个定义在另一个类中的类，叫作内部类。</p>
</blockquote>
<p>###创建内部类</p>
<p>把类的定义置于外部类的里面</p>
<p>如果想从外部类的非静态方法之外的任意位置创建某个内部类的对象，那么必须像在 <code>main()</code> 方法中那样，具体地指明这个对象的类型：<em>OuterClassName.InnerClassName</em>。</p>
<p>###链接外部类</p>
<p>内部类不只是一种名字隐藏和组织代码的模式。</p>
<p>内部类自动拥有对其外部类所有成员的访问权。</p>
<blockquote>
<p>这是如何做到的呢？当某个外部类的对象创建了一个内部类对象时，此内部类对象必定会秘密地捕获一个指向那个外部类对象的引用。然后，在你访问此外部类的成员时，就是用那个引用来选择外部类的成员。幸运的是，编译器会帮你处理所有的细节，但你现在可以看到：内部类的对象只能在与其外部类的对象相关联的情况下才能被创建（就像你应该看到的，内部类是非 <strong>static</strong> 类时）。构建内部类对象时，需要一个指向其外部类对象的引用，如果编译器访问不到这个引用就会报错</p>
</blockquote>
<p>###this和new</p>
<p>如果你需要生成对外部类对象的引用，可以使用外部类的名字后面紧跟圆点和 <strong>this</strong>。</p>
<pre><code class="java">// innerclasses/DotThis.java
// Accessing the outer-class object
public class DotThis &#123;
    void f() &#123; System.out.println(&quot;DotThis.f()&quot;); &#125;

    public class Inner &#123;
        public DotThis outer() &#123;
            return DotThis.this;
            // A plain &quot;this&quot; would be Inner&#39;s &quot;this&quot;
        &#125;
    &#125;

    public Inner inner() &#123; return new Inner(); &#125;

    public static void main(String[] args) &#123;
        DotThis dt = new DotThis();
        DotThis.Inner dti = dt.inner();
        dti.outer().f();
    &#125;
&#125;

/* 输出

DotThis.f()

*/</code></pre>
<p>告知某些其他对象，去创建其某个内部类的对象。要实现此目的，你必须在 <strong>new</strong> 表达式中提供对其他外部类对象的引用，这是需要使用 <strong>.new</strong> 语法。要想直接创建内部类的对象，你不能按照你想象的方式，去引用外部类的名字 <strong>DotNew</strong>，而是必须使用外部类的对象来创建该内部类对象。</p>
<pre><code class="java">// innerclasses/DotNew.java
// Creating an inner class directly using .new syntax
public class DotNew &#123;
    public class Inner &#123;&#125;
    public static void main(String[] args) &#123;
        DotNew dn = new DotNew();
        DotNew.Inner dni = dn.new Inner();
    &#125;
&#125;</code></pre>
<p>在拥有外部类对象之前是不可能创建内部类对象的。这是因为内部类对象会暗暗地连接到建它的外部类对象上。但是，如果你创建的是嵌套类（静态内部类），那么它就不需要对外部类对象的引用。</p>
<p>###内部类与向上转型</p>
<p>当将内部类向上转型为其基类，尤其是转型为一个接口的时候，内部类就有了用武之地。</p>
<p>这是因为此内部类-某个接口的实现-能够完全不可见，并且不可用。所得到的只是指向基类或接口的引用，所以能够很方便地隐藏实现细节。</p>
<pre><code class="java">// innerclasses/Destination.java
public interface Destination &#123;
    String readLabel();
&#125;</code></pre>
<pre><code class="java">// innerclasses/Contents.java
public interface Contents &#123;
    int value();
&#125;</code></pre>
<p>两个可用的接口。当取得了一个指向基类或接口的引用时，甚至可能无法找出它确切的类型，看下面的例子：</p>
<pre><code class="java">// innerclasses/TestParcel.java
class Parcel4 &#123;
    private class PContents implements Contents &#123;
        private int i = 11;
        @Override
        public int value() &#123; return i; &#125;
    &#125;
    protected final class PDestination implements Destination &#123;
        private String label;
        private PDestination(String whereTo) &#123;
            label = whereTo;
        &#125;
        @Override
        public String readLabel() &#123; return label; &#125;
    &#125;
    public Destination destination(String s) &#123;
        return new PDestination(s);
    &#125;
    public Contents contents() &#123;
        return new PContents();
    &#125;
&#125;
public class TestParcel &#123;
    public static void main(String[] args) &#123;
        Parcel4 p = new Parcel4();
        Contents c = p.contents();
        Destination d = p.destination(&quot;Tasmania&quot;);
        // Illegal -- can&#39;t access private class:
        //- Parcel4.PContents pc = p.new PContents();
    &#125;
&#125;</code></pre>
<p>在 <strong>Parcel4</strong> 中，内部类 <strong>PContents</strong> 是 <strong>private</strong>，所以除了 <strong>Parcel4</strong>，没有人能访问它。</p>
<p><strong>PDestination</strong> 是 <strong>protected</strong>，所以只有 <strong>Parcel4</strong> 及其子类、还有与 <strong>Parcel4</strong> 同一个包中的类（因为 <strong>protected</strong> 也给予了包访问权）能访问 <strong>PDestination</strong>。</p>
<p><strong>private</strong> 内部类给类的设计者提供了一种途径，通过这种方式可以完全阻止任何依赖于类型的编码，并且完全隐藏了实现的细节。</p>
<p>###内部类方法和作用域</p>
<p>可以在一个方法里面或者在任意的作用域内定义内部类。</p>
<p>这么做有两个理由：</p>
<ol>
<li>如前所示，你实现了某类型的接口，于是可以创建并返回对其的引用。</li>
<li>你要解决一个复杂的问题，想创建一个类来辅助你的解决方案，但是又不希望这个类是公共可用的。</li>
</ol>
<p>例子1:展示了在方法的作用域内（而不是在其他类的作用域内）创建一个完整的类。这被称作局部内部类：</p>
<pre><code class="java">// innerclasses/Parcel5.java
// Nesting a class within a method
public class Parcel5 &#123;
    public Destination destination(String s) &#123;
        final class PDestination implements Destination &#123;
            private String label;

            private PDestination(String whereTo) &#123;
                label = whereTo;
            &#125;

            @Override
            public String readLabel() &#123; return label; &#125;
        &#125;
        return new PDestination(s);
    &#125;

    public static void main(String[] args) &#123;
        Parcel5 p = new Parcel5();
        Destination d = p.destination(&quot;Tasmania&quot;);
    &#125;
&#125;</code></pre>
<p>你可以在同一个子目录下的任意类中对某个内部类使用类标识符 <strong>PDestination</strong>，这并不会有命名冲突</p>
<p>例子2：展示了如何在任意的作用域内嵌入一个内部类：</p>
<pre><code class="java">// innerclasses/Parcel6.java
// Nesting a class within a scope
public class Parcel6 &#123;
    private void internalTracking(boolean b) &#123;
        if(b) &#123;
            class TrackingSlip &#123;
                private String id;
                TrackingSlip(String s) &#123;
                    id = s;
                &#125;
                String getSlip() &#123; return id; &#125;
            &#125;
            TrackingSlip ts = new TrackingSlip(&quot;slip&quot;);
            String s = ts.getSlip();
        &#125;
        // Can&#39;t use it here! Out of scope:
        //- TrackingSlip ts = new TrackingSlip(&quot;x&quot;);
    &#125;
    public void track() &#123; internalTracking(true); &#125;
    public static void main(String[] args) &#123;
        Parcel6 p = new Parcel6();
        p.track();
    &#125;
&#125;</code></pre>
<p><strong>TrackingSlip</strong> 类被嵌入在 <strong>if</strong> 语句的作用域内，这并不是说该类的创建是有条件的，它其实与别的类一起编译过了。然而，在定义 <strong>Trackingslip</strong> 的作用域之外，它是不可用的，除此之外，它与普通的类一样。</p>
<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>通过 <strong>new</strong> 表达式返回的引用被自动向上转型为对 <strong>Contents</strong> 的引用。</p>
<pre><code class="java">// innerclasses/Parcel7.java
// Returning an instance of an anonymous inner class
public class Parcel7 &#123;
    public Contents contents() &#123;
        return new Contents() &#123; // Insert class definition
            private int i = 11;

            @Override
            public int value() &#123; return i; &#125;
        &#125;; // Semicolon required
    &#125;

    public static void main(String[] args) &#123;
        Parcel7 p = new Parcel7();
        Contents c = p.contents();
    &#125;
&#125;</code></pre>
<p>上述匿名内部类的语法是下述形势的简化：</p>
<pre><code class="java">// innerclasses/Parcel7b.java
// Expanded version of Parcel7.java
public class Parcel7b &#123;
    class MyContents implements Contents &#123;
        private int i = 11;
        @Override
        public int value() &#123; return i; &#125;
    &#125;

    public Contents contents() &#123;
        return new MyContents();
    &#125;

    public static void main(String[] args) &#123;
        Parcel7b p = new Parcel7b();
        Contents c = p.contents();
    &#125;
&#125;</code></pre>
<p>如果基类需要一个有参数的构造器：</p>
<pre><code class="java">// innerclasses/Parcel8.java
// Calling the base-class constructor
public class Parcel8 &#123;
    public Wrapping wrapping(int x) &#123;
        // Base constructor call:
        return new Wrapping(x) &#123; // [1]
            @Override
            public int value() &#123;
                return super.value() * 47;
            &#125;
        &#125;; // [2]
    &#125;
    public static void main(String[] args) &#123;
        Parcel8 p = new Parcel8();
        Wrapping w = p.wrapping(10);
    &#125;
&#125;</code></pre>
<p>在匿名类中不可能有命名构造器（因为它根本没名字！），但通过实例初始化，就能够达到为匿名内部类创建一个构造器的效果，就像这样：</p>
<pre><code class="java">// innerclasses/AnonymousConstructor.java
// Creating a constructor for an anonymous inner class
abstract class Base &#123;
    Base(int i) &#123;
        System.out.println(&quot;Base constructor, i = &quot; + i);
    &#125;
    public abstract void f();
&#125;
public class AnonymousConstructor &#123;
    public static Base getBase(int i) &#123;
        return new Base(i) &#123;
            &#123; System.out.println(
                    &quot;Inside instance initializer&quot;); &#125;
            @Override
            public void f() &#123;
                System.out.println(&quot;In anonymous f()&quot;);
            &#125;
        &#125;;
    &#125;
    public static void main(String[] args) &#123;
        Base base = getBase(47);
        base.f();
    &#125;
&#125;</code></pre>
<p>在此例中，不要求变量一定是 <strong>final</strong> 的。因为被传递给匿名类的基类的构造器，它并不会在匿名类内部被直接使用。注意 <code>destination()</code> 的参数必须是 <strong>final</strong> 的，因为它们是在匿名类内部使用的</p>
<pre><code class="java">// innerclasses/Parcel10.java
// Using &quot;instance initialization&quot; to perform
// construction on an anonymous inner class
public class Parcel10 &#123;
    public Destination
    destination(final String dest, final float price) &#123;
        return new Destination() &#123;
            private int cost;
            // Instance initialization for each object:
            &#123;
                cost = Math.round(price);
                if(cost &gt; 100)
                    System.out.println(&quot;Over budget!&quot;);
            &#125;
            private String label = dest;
            @Override
            public String readLabel() &#123; return label; &#125;
        &#125;;
    &#125;
    public static void main(String[] args) &#123;
        Parcel10 p = new Parcel10();
        Destination d = p.destination(&quot;Tasmania&quot;, 101.395F);
    &#125;
&#125;</code></pre>
<p>匿名内部类与正规的继承相比有些受限，因为匿名内部类既可以扩展类，也可以实现接口，但是不能两者兼备。而且如果是实现接口，也只能实现一个接口。</p>
<p>###嵌套类</p>
<blockquote>
<p>如果不需要内部类对象与其外部类对象之间有联系，那么可以将内部类声明为 <strong>static</strong>，这通常称为嵌套类。</p>
<ol>
<li>要创建嵌套类的对象，并不需要其外部类的对象。</li>
<li>不能从嵌套类的对象中访问非静态的外部类对象。</li>
</ol>
</blockquote>
<p>普通内部类的字段与方法，只能放在类的外部层次上，所以普通的内部类不能有 <strong>static</strong> 数据和 <strong>static</strong> 字段，也不能包含嵌套类。但是嵌套类可以包含所有这些东西：</p>
<pre><code class="java">// innerclasses/Parcel11.java
// Nested classes (static inner classes)
public class Parcel11 &#123;
    private static class ParcelContents implements Contents &#123;
        private int i = 11;
        @Override
        public int value() &#123; return i; &#125;
    &#125;
    protected static final class ParcelDestination
            implements Destination &#123;
        private String label;
        private ParcelDestination(String whereTo) &#123;
            label = whereTo;
        &#125;
        @Override
        public String readLabel() &#123; return label; &#125;
        // Nested classes can contain other static elements:
        public static void f() &#123;&#125;
        static int x = 10;
        static class AnotherLevel &#123;
            public static void f() &#123;&#125;
            static int x = 10;
        &#125;
    &#125;
    public static Destination destination(String s) &#123;
        return new ParcelDestination(s);
    &#125;
    public static Contents contents() &#123;
        return new ParcelContents();
    &#125;
    public static void main(String[] args) &#123;
        Contents c = contents();
        Destination d = destination(&quot;Tasmania&quot;);
    &#125;
&#125;</code></pre>
<p>嵌套类可以作为接口的一部分。你放到接口中的任何类都自动地是 <strong>public</strong> 和 <strong>static</strong> 的。你甚至可以在内部类中实现其外部接口，就像下面这样：</p>
<pre><code class="java">// innerclasses/ClassInInterface.java
// &#123;java ClassInInterface$Test&#125;
public interface ClassInInterface &#123;
    void howdy();
    class Test implements ClassInInterface &#123;
        @Override
        public void howdy() &#123;
            System.out.println(&quot;Howdy!&quot;);
        &#125;
        public static void main(String[] args) &#123;
            new Test().howdy();
        &#125;
    &#125;
&#125;</code></pre>
<p>如果你想要创建某些公共代码，使得它们可以被某个接口的所有不同实现所共用，那么使用接口内部的嵌套类会显得很方便。</p>
<p>在每个类中都写一个 <code>main()</code> 方法，用来测试这个类。这样做有一个缺点，那就是必须带着那些已编译过的额外代码。如果这对你是个麻烦，那就可以使用嵌套类来放置测试代码。</p>
<pre><code class="java">// innerclasses/TestBed.java
// Putting test code in a nested class
// &#123;java TestBed$Tester&#125;
public class TestBed &#123;
    public void f() &#123; System.out.println(&quot;f()&quot;); &#125;
    public static class Tester &#123;
        public static void main(String[] args) &#123;
            TestBed t = new TestBed();
            t.f();
        &#125;
    &#125;
&#125;</code></pre>
<p>从多层嵌套类中访问 外部类的成员</p>
<p>一个内部类被嵌套多少层并不重要——它能透明地访问所有它所嵌入的外部类的所有成员</p>
<pre><code class="java">// innerclasses/MultiNestingAccess.java
// Nested classes can access all members of all
// levels of the classes they are nested within
class MNA &#123;
    private void f() &#123;&#125;
    class A &#123;
        private void g() &#123;&#125;
        public class B &#123;
            void h() &#123;
                g();
                f();
            &#125;
        &#125;
    &#125;
&#125;
public class MultiNestingAccess &#123;
    public static void main(String[] args) &#123;
        MNA mna = new MNA();
        MNA.A mnaa = mna.new A();
        MNA.A.B mnaab = mnaa.new B();
        mnaab.h();
    &#125;
&#125;</code></pre>
<h3 id="为什么需要内部类"><a href="#为什么需要内部类" class="headerlink" title="为什么需要内部类"></a>为什么需要内部类</h3><p>内部类继承自某个类或实现某个接口，内部类的代码操作创建它的外部类的对象。所以可以认为内部类提供了某种进入其外部类的窗口。</p>
<p>每个内部类都能独立地继承自一个（接口的）实现，所以无论外部类是否已经继承了某个（接口的）实现，对于内部类都没有影响。</p>
<p>内部类使得多重继承的解决方案变得完整。接口解决了部分问题，而内部类有效地实现了“多重继承”。也就是说，内部类允许继承多个非接口类型（译注：类或抽象类）。</p>
<p>为了看到更多的细节，让我们考虑这样一种情形：即必须在一个类中以某种方式实现两个接口。由于接口的灵活性，你有两种选择；使用单一类，或者使用内部类：</p>
<pre><code class="java">// innerclasses/mui/MultiInterfaces.java
// Two ways a class can implement multiple interfaces
// &#123;java innerclasses.mui.MultiInterfaces&#125;
package innerclasses.mui;
interface A &#123;&#125;
interface B &#123;&#125;
class X implements A, B &#123;&#125;
class Y implements A &#123;
    B makeB() &#123;
        // Anonymous inner class:
        return new B() &#123;&#125;;
    &#125;
&#125;
public class MultiInterfaces &#123;
    static void takesA(A a) &#123;&#125;
    static void takesB(B b) &#123;&#125;
    public static void main(String[] args) &#123;
        X x = new X();
        Y y = new Y();
        takesA(x);
        takesA(y);
        takesB(x);
        takesB(y.makeB());
    &#125;
&#125;</code></pre>
<p>如果拥有的是抽象的类或具体的类，而不是接口，那就只能使用内部类才能实现多重继承：</p>
<pre><code class="java">// innerclasses/MultiImplementation.java
// For concrete or abstract classes, inner classes
// produce &quot;multiple implementation inheritance&quot;
// &#123;java innerclasses.MultiImplementation&#125;
package innerclasses;

class D &#123;&#125;

abstract class E &#123;&#125;

class Z extends D &#123;
    E makeE() &#123;
      return new E() &#123;&#125;;  
    &#125;
&#125;

public class MultiImplementation &#123;
    static void takesD(D d) &#123;&#125;
    static void takesE(E e) &#123;&#125;

    public static void main(String[] args) &#123;
        Z z = new Z();
        takesD(z);
        takesE(z.makeE());
    &#125;
&#125;</code></pre>
<p>如果不需要解决“多重继承”的问题，那么自然可以用别的方式编码，而不需要使用内部类。但如果使用内部类，还可以获得其他一些特性：</p>
<ol>
<li>内部类可以有多个实例，每个实例都有自己的状态信息，并且与其外部类对象的信息相互独立。</li>
<li>在单个外部类中，可以让多个内部类以不同的方式实现同一个接口，或继承同一个类。 稍后就会展示一个这样的例子。</li>
<li>创建内部类对象的时刻并不依赖于外部类对象的创建</li>
<li>内部类并没有令人迷惑的”is-a”关系，它就是一个独立的实体。</li>
</ol>
<p>###闭包与回调</p>
<p>通过内部类提供闭包的功能是优良的解决方案，它比指针更灵活、更安全。</p>
<pre><code class="java">// innerclasses/Callbacks.java
// Using inner classes for callbacks
// &#123;java innerclasses.Callbacks&#125;
package innerclasses;
interface Incrementable &#123;
    void increment();
&#125;
// Very simple to just implement the interface:
class Callee1 implements Incrementable &#123;
    private int i = 0;
    @Override
    public void increment() &#123;
        i++;
        System.out.println(i);
    &#125;
&#125;
class MyIncrement &#123;
    public void increment() &#123;
        System.out.println(&quot;Other operation&quot;);
    &#125;
    static void f(MyIncrement mi) &#123; mi.increment(); &#125;
&#125;
// If your class must implement increment() in
// some other way, you must use an inner class:
class Callee2 extends MyIncrement &#123;
    private int i = 0;
    @Override
    public void increment() &#123;
        super.increment();
        i++;
        System.out.println(i);
    &#125;
    private class Closure implements Incrementable &#123;
        @Override
        public void increment() &#123;
            // Specify outer-class method, otherwise
            // you&#39;ll get an infinite recursion:
            Callee2.this.increment();
        &#125;
    &#125;
    Incrementable getCallbackReference() &#123;
        return new Closure();
    &#125;
&#125;
class Caller &#123;
    private Incrementable callbackReference;
    Caller(Incrementable cbh) &#123;
        callbackReference = cbh;
    &#125;
    void go() &#123; callbackReference.increment(); &#125;
&#125;
public class Callbacks &#123;
    public static void main(String[] args) &#123;
        Callee1 c1 = new Callee1();
        Callee2 c2 = new Callee2();
        MyIncrement.f(c2);
        Caller caller1 = new Caller(c1);
        Caller caller2 =
                new Caller(c2.getCallbackReference());
        caller1.go();
        caller1.go();
        caller2.go();
        caller2.go();
    &#125;
&#125;</code></pre>
<pre><code class="java">Other operation
1
1
2
Other operation
2
Other operation
3</code></pre>
</div><hr></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By John Doe</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>